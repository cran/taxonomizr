<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Introduction</h2>

<p><code>taxonomizr</code> provides some simple functions to parse NCBI taxonomy files and accession dumps and efficiently use them to assign <a href="https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/">taxonomy</a> to accession numbers or taxonomic IDs. This is useful for example to assign taxonomy to BLAST results. This is all done locally after downloading the appropriate files from NCBI using included functions (see <a href="#preparation">below</a>). </p>

<p>The major functions are:</p>

<ul>
<li><code>prepareDatabase</code>: download data from NCBI and prepare SQLite database</li>
<li><code>accessionToTaxa</code>: convert accession numbers to taxonomic IDs</li>
<li><code>getTaxonomy</code>: convert taxonomic IDs to taxonomy</li>
</ul>

<p>More specialized functions are:</p>

<ul>
<li><code>getId</code>: convert a biological name to taxonomic ID</li>
<li><code>getAccessions</code>: find accessions for a given taxonomic ID</li>
</ul>

<p>And a simple use case might look like (see below for more details):</p>

<pre><code class="r">library(taxonomizr)
#note this will require a lot of hard drive space, bandwidth and time to process all the data from NCBI
prepareDatabase(&#39;accessionTaxa.sql&#39;)
blastAccessions&lt;-c(&quot;Z17430.1&quot;,&quot;Z17429.1&quot;,&quot;X62402.1&quot;) 
ids&lt;-accessionToTaxa(blastAccessions,&#39;accessionTaxa.sql&#39;)
getTaxonomy(ids,&#39;accessionTaxa.sql&#39;)
</code></pre>

<h2>Requirements</h2>

<p>This package downloads a few databases from NCBI and stores them in an easily accessible form on the hard drive. This ends up taking a decent amount of space so you&#39;ll probably want around 75 Gb of free hard drive space. </p>

<h2>Installation</h2>

<p>The package is on CRAN, so it should install with a simple:</p>

<pre><code class="r">install.packages(&quot;taxonomizr&quot;)
</code></pre>

<p>If you want the development version directly from github, use the <a href="https://github.com/hadley/devtools"><code>devtools</code></a> library and run:</p>

<pre><code class="r">devtools::install_github(&quot;sherrillmix/taxonomizr&quot;)
</code></pre>

<p>To use the library, load it in R:</p>

<pre><code class="r">library(taxonomizr)
</code></pre>

<h2>Preparation<a name="preparation"></a></h2>

<p>Since version 0.5.0, there is a simple function to run all preparations. Note that you&#39;ll need a bit of time, download bandwidth and hard drive space before running this command (we&#39;re downloading taxonomic assignments for every record in NCBI). To create a SQLite database called <code>accessionTaxa.sql</code> in the current working directory (you may want to store this somewhere more centrally located so it does not need to be duplicated with every project), we can run:</p>

<pre><code class="r">prepareDatabase(&#39;accessionTaxa.sql&#39;)
</code></pre>

<pre><code>## Downloading names and nodes with getNamesAndNodes()
</code></pre>

<pre><code>## Downloading accession2taxid with getAccession2taxid()
</code></pre>

<pre><code>## This can be a big (several gigabytes) download. Please be patient and use a fast connection.
</code></pre>

<pre><code>## Preprocessing names with read.names.sql()
</code></pre>

<pre><code>## Preprocessing nodes with read.nodes.sql()
</code></pre>

<pre><code>## Preprocessing accession2taxid with read.accession2taxid()
</code></pre>

<pre><code>## Reading ./nucl_gb.accession2taxid.gz.
</code></pre>

<pre><code>## Reading ./nucl_wgs.accession2taxid.gz.
</code></pre>

<pre><code>## Reading in values. This may take a while.
</code></pre>

<pre><code>## Adding index. This may also take a while.
</code></pre>

<pre><code>## [1] &quot;accessionTaxa.sql&quot;
</code></pre>

<p>If everything works then that should have prepared a SQLite database ready for use. You can skip the &ldquo;Manual preparation&rdquo; steps below.</p>

<p>All files are cached locally and so the preparation is only required once (delete/rename the SQLite database and recall the function to regenerate the database). It is not necessary to manually check for the presence of the database since the function checks to see if SQLite database is present and if so skips downloading/processing. For example, running the command again produces:</p>

<pre><code class="r">prepareDatabase(&#39;accessionTaxa.sql&#39;)
</code></pre>

<pre><code>## SQLite database accessionTaxa.sql already exists. Delete to regenerate
</code></pre>

<pre><code>## [1] &quot;accessionTaxa.sql&quot;
</code></pre>

<h2>Assigning taxonomy</h2>

<h3>Finding taxonomy for NCBI accession numbers</h3>

<p>NCBI accession numbers are often obtained when doing a BLAST search (usually the second column of output from blastn, blastx, blastp, &hellip;). So to identify a taxon for a given sequence you would blast it against e.g. the NCBI nt database and load the results into R.</p>

<p>Now we are ready to convert NCBI accession numbers to taxonomic IDs. For example, to find the taxonomic IDs associated with NCBI accession numbers &ldquo;LN847353.1&rdquo; and &ldquo;AL079352.3&rdquo;:</p>

<pre><code class="r">taxaId&lt;-accessionToTaxa(c(&quot;LN847353.1&quot;,&quot;AL079352.3&quot;),&quot;accessionTaxa.sql&quot;)
print(taxaId)
</code></pre>

<pre><code>## [1] 1313 9606
</code></pre>

<p>And to get the taxonomy for those IDs:</p>

<pre><code class="r">getTaxonomy(taxaId,&#39;accessionTaxa.sql&#39;)
</code></pre>

<pre><code>##      superkingdom phylum       class      order            
## 1313 &quot;Bacteria&quot;   &quot;Firmicutes&quot; &quot;Bacilli&quot;  &quot;Lactobacillales&quot;
## 9606 &quot;Eukaryota&quot;  &quot;Chordata&quot;   &quot;Mammalia&quot; &quot;Primates&quot;       
##      family             genus           species                   
## 1313 &quot;Streptococcaceae&quot; &quot;Streptococcus&quot; &quot;Streptococcus pneumoniae&quot;
## 9606 &quot;Hominidae&quot;        &quot;Homo&quot;          &quot;Homo sapiens&quot;
</code></pre>

<p>You can also get taxonomy for NCBI accession numbers without versions (the .X following the main number e.g. the &ldquo;.1&rdquo; in LN847353.1) using the <code>version=&#39;base&#39;</code> argument of <code>accessionToTaxa</code>:</p>

<pre><code class="r">taxaId&lt;-accessionToTaxa(c(&quot;LN847353&quot;,&quot;AL079352&quot;),&quot;accessionTaxa.sql&quot;)
print(taxaId)
</code></pre>

<pre><code>## [1] NA NA
</code></pre>

<pre><code class="r">taxaId&lt;-accessionToTaxa(c(&quot;LN847353&quot;,&quot;AL079352&quot;),&quot;accessionTaxa.sql&quot;,version=&#39;base&#39;)
print(taxaId)
</code></pre>

<pre><code>## [1] 1313 9606
</code></pre>

<h3>Finding taxonomy for taxonomic names</h3>

<p>If you&#39;d like to find IDs for taxonomic names then you can do something like:</p>

<pre><code class="r">taxaId&lt;-getId(c(&#39;Homo sapiens&#39;,&#39;Bos taurus&#39;,&#39;Homo&#39;,&#39;Alces alces&#39;),&#39;accessionTaxa.sql&#39;)
print(taxaId)
</code></pre>

<pre><code>## [1] &quot;9606&quot; &quot;9913&quot; &quot;9605&quot; &quot;9852&quot;
</code></pre>

<p>And again to get the taxonomy for those IDs use <code>getTaxonomy</code>:</p>

<pre><code class="r">taxa&lt;-getTaxonomy(taxaId,&#39;accessionTaxa.sql&#39;)
print(taxa)
</code></pre>

<pre><code>
##      superkingdom phylum     class      order      family      genus  
## 9606 &quot;Eukaryota&quot;  &quot;Chordata&quot; &quot;Mammalia&quot; &quot;Primates&quot; &quot;Hominidae&quot; &quot;Homo&quot; 
## 9913 &quot;Eukaryota&quot;  &quot;Chordata&quot; &quot;Mammalia&quot; NA         &quot;Bovidae&quot;   &quot;Bos&quot;  
## 9605 &quot;Eukaryota&quot;  &quot;Chordata&quot; &quot;Mammalia&quot; &quot;Primates&quot; &quot;Hominidae&quot; &quot;Homo&quot; 
## 9852 &quot;Eukaryota&quot;  &quot;Chordata&quot; &quot;Mammalia&quot; NA         &quot;Cervidae&quot;  &quot;Alces&quot;
##      species       
## 9606 &quot;Homo sapiens&quot;
## 9913 &quot;Bos taurus&quot;  
## 9605 NA            
## 9852 &quot;Alces alces&quot;
</code></pre>

<h3>Condensing taxonomy</h3>

<p>You can use the <code>condenseTaxa</code> function to find the agreements among taxonomic hits. For example to condense the taxonomy from the previous section to the lowest taxonomic rank shared by all three taxa:</p>

<pre><code class="r">condenseTaxa(taxa)
</code></pre>

<pre><code>##   superkingdom phylum     class      order family genus species
## 1 &quot;Eukaryota&quot;  &quot;Chordata&quot; &quot;Mammalia&quot; NA    NA     NA    NA
</code></pre>

<p>This function can also be fed a large number of grouped hits, e.g. BLAST hits for high throughput sequencing reads after filtering for the best hits for each read, and output a condensed taxonomy for each grouping:</p>

<pre><code class="r">groupings&lt;-c(&#39;read1&#39;,&#39;read2&#39;,&#39;read1&#39;,&#39;read2&#39;)
condenseTaxa(taxa,groupings)
</code></pre>

<pre><code>##       superkingdom phylum     class      order      family      genus 
## read1 &quot;Eukaryota&quot;  &quot;Chordata&quot; &quot;Mammalia&quot; &quot;Primates&quot; &quot;Hominidae&quot; &quot;Homo&quot;
## read2 &quot;Eukaryota&quot;  &quot;Chordata&quot; &quot;Mammalia&quot; NA         NA          NA    
##       species
## read1 NA     
## read2 NA
</code></pre>

<h3>Finding accessions for a given taxonomic ID</h3>

<p>To find all the accessions for a given taxonomic ID, you can use the <code>getAccessions</code> function. This is a bit of an unusual use case so to preserve space, an index is not created by default in <code>read.accession2taxid</code>. If you are going to use this function, you will want to rebuild the SQLite database with the <code>indexTaxa</code> argument set to true with something like:</p>

<pre><code class="r">read.accession2taxid(list.files(&#39;.&#39;,&#39;accession2taxid.gz$&#39;),&#39;accessionTaxa.sql&#39;,indexTaxa=TRUE,overwrite=TRUE)
</code></pre>

<pre><code>## Reading nucl_gb.accession2taxid.gz.
</code></pre>

<pre><code>## Reading nucl_wgs.accession2taxid.gz.
</code></pre>

<pre><code>## Reading in values. This may take a while.
</code></pre>

<pre><code>## Adding index. This may also take a while.
</code></pre>

<p>Then you can get the accessions for taxa 3702 with a command like (note that the limit argument is used here in order to preserve space):</p>

<pre><code class="r">getAccessions(3702,&#39;accessionTaxa.sql&#39;,limit=10)
</code></pre>

<pre><code>##    taxa accession
## 1  3702  X58148.1
## 2  3702  X66414.1
## 3  3702  X60045.1
## 4  3702  X07376.1
## 5  3702  X54927.1
## 6  3702  X54926.1
## 7  3702  X54928.1
## 8  3702  X54930.1
## 9  3702  X54929.1
## 10 3702  X52320.1
</code></pre>

<h2>Changelog</h2>

<h3>v0.5.3</h3>

<ul>
<li>Remove <code>nucl_est</code> and <code>nucl_gss</code> from defaults since NCBI folded them into <code>nucl_gb</code> and removed</li>
<li>Squash R:devel bug</li>
</ul>

<h3>v0.5.0</h3>

<ul>
<li>Transitioned from data.table to SQLite</li>
<li>Addeded convenience <code>prepareDatabase()</code> function</li>
<li>Squashed Windows testing errors</li>
</ul>

<h2>Manual preparation of database (usually not necessary)</h2>

<p><strong>Note:</strong> Since version 0.5.0, it is usually not necessary to run the following manually, the function <code>prepareDatabase()</code> should do most of this automatically for you (see <a href='#preparation'>above</a>).</p>

<p>In order to avoid constant internet access and slow APIs, the first step in using the package is to downloads all necessary files from NCBI. This uses a bit of disk space but makes future access reliable and fast.</p>

<p><strong>Note:</strong> It is not necessary to manually check for the presence of these files since the functions automatically check to see if their output is present and if so skip downloading/processing. Delete the local files if you would like to redownload or reprocess them.</p>

<h3>Download names and nodes</h3>

<p>First, download the necessary names and nodes files from <a href="ftp://ftp.ncbi.nih.gov/pub/taxonomy/">NCBI</a>:</p>

<pre><code class="r">getNamesAndNodes()
</code></pre>

<pre><code>## [1] &quot;./names.dmp&quot; &quot;./nodes.dmp&quot;
</code></pre>

<h3>Download accession to taxa files</h3>

<p>Then download accession to taxa id conversion files from <a href="ftp://ftp.ncbi.nih.gov/pub/taxonomy/accession2taxid/">NCBI</a>. <strong>Note:</strong> this is a pretty <em>big</em> download (several gigabytes):</p>

<pre><code class="r">#this is a big download
getAccession2taxid()
</code></pre>

<pre><code>## This can be a big (several gigabytes) download. Please be patient and use a fast connection.
</code></pre>

<pre><code>## [1] &quot;./nucl_gb.accession2taxid.gz&quot;  &quot;./nucl_wgs.accession2taxid.gz&quot;
</code></pre>

<p>If you would also like to identify protein accession numbers, also download the prot file from NCBI (again this is a <em>big</em> download):</p>

<pre><code class="r">#this is a big download
getAccession2taxid(types=&#39;prot&#39;)
</code></pre>

<pre><code>## This can be a big (several gigabytes) download. Please be patient and use a fast connection.
</code></pre>

<pre><code>## [1] &quot;./prot.accession2taxid.gz&quot;
</code></pre>

<h3>Convert names, nodes and accessions to database</h3>

<p>Then process the downloaded names and nodes files into a more easily accessed form:</p>

<pre><code class="r">read.names.sql(&#39;names.dmp&#39;,&#39;accessionTaxa.sql&#39;)
read.nodes.sql(&#39;nodes.dmp&#39;,&#39;accessionTaxa.sql&#39;)
</code></pre>

<p>Next process the downloaded accession files into the same database (this one could take a while):</p>

<pre><code class="r">read.accession2taxid(list.files(&#39;.&#39;,&#39;accession2taxid.gz$&#39;),&#39;accessionTaxa.sql&#39;)
</code></pre>

<pre><code>## Reading nucl_gb.accession2taxid.gz.
</code></pre>

<pre><code>## Reading nucl_wgs.accession2taxid.gz.
</code></pre>

<pre><code>## Reading prot.accession2taxid.gz.
</code></pre>

<pre><code>## Reading in values. This may take a while.
</code></pre>

<pre><code>## Adding index. This may also take a while.
</code></pre>

<p>Now everything should be ready for processing. All files are cached locally and so the preparation is only required once (or whenever you would like to update the data). It is not necessary to manually check for the presence of these files since the functions automatically check to see if their output is present and if so skip downloading/processing. Delete the local files if you would like to redownload or reprocess them.</p>

<h2>Switch from data.table to SQLite</h2>

<p>Version 0.5.0 marked a change for name and node lookups from using data.table to using SQLite. This was necessary to increase performance (10-100x speedup for <code>getTaxonomy</code>) and create a simpler interface (a single SQLite database contains all necessary data). Unfortunately, this switch requires a couple breaking changes: </p>

<ul>
<li><code>getTaxonomy</code> changes from <code>getTaxonomy(ids,namesDT,nodesDT)</code> to <code>getTaxonomy(ids,sqlFile)</code></li>
<li><code>getId</code> changes from  <code>getId(taxa,namesDT)</code> to <code>getId(taxa,sqlFile)</code></li>
<li><code>read.names</code> is deprecated, instead use <code>read.names.sql</code>. For example, instead of calling <code>names&lt;-read.names(&#39;names.dmp&#39;)</code> in every session, simply call <code>read.names.sql(&#39;names.dmp&#39;,&#39;accessionTaxa.sql&#39;)</code> once (or use the convenient <code>prepareDatabase</code> as <a href='#preparation'>above</a>)).</li>
<li><p><code>read.nodes</code> is deprecated, instead use <code>read.names.sql</code>. For example. instead of calling <code>nodes&lt;-read.names(&#39;nodes.dmp&#39;)</code> in every session, simply call <code>read.nodes.sql(&#39;nodes.dmp&#39;,&#39;accessionTaxa.sql&#39;)</code> once (or use the convenient <code>prepareDatabase</code> as <a href='#preparation'>above</a>).</p>

<p>I&#39;ve tried to ease any problems with this by overloading <code>getTaxonomy</code> and <code>getId</code> to still function (with a warning) if passed a data.table names and nodes argument and providing a simpler <code>prepareDatabase</code> function for completing all setup steps (hopefully avoiding direct calls to <code>read.names</code> and <code>read.nodes</code> for most users). </p></li>
</ul>

<p>I plan to eventually remove data.table functionality to avoid a split codebase so please switch to the new SQLite format in all new code.</p>

</body>

</html>
